

# 计算机网络复习@Zerun Li

## 基础：

#### OSI五层模型

- 应用层   进程到进程   报文                     SMTP\Telnet\HTTP\FTP           
- 传输层   进程到进程   报文段    Segment
- 网络层   主机到主机   数据报    Datagram
- 链路层   端到端           帧
- 物理层                           比特

## 应用层

#### 常用网络体系

1. 客户-服务器 C/S架构
2. 点对点结构 P2P
   - 高度可伸缩
   - 难于管理
3. 混合结构 Hybrid
   - 文件传输用P2P
   - 文件搜索用C/S架构



进程标识符：IP地址+端口号



#### HTTP概述

1. HTTP是无状态的 不维护任何过去客户端发出的请求
2. HTTP是一种‘拉’协议，把内容从服务器拉回来
3. HTTP有非持久性连接(每个连接只传输一个对象)和持久性连接(一个连接可以传输多个对象)
4. 持久性连接
   - 无流水线的--接收端收到前一个响应后才发起新的请求
   - 带有流水线机制的--客户端只要有需要的对象就发出请求 无需等待上一个响应
5. HTTP格式：POST、GET、DELETE、PUT、HEAD
6. HTTP响应码： 200-OK    400-请求错误    404-NOT Found   505-HTTP版本不支持



#### WEB缓存技术

在不访问服务器前提下满足用户HTTP请求

- 好处：缩短客户机请求的响应时间、减少机构流量、大范围内实现有效的内容分发
- 过程：用户对缓存服务器发起HTTP请求：
  - 若请求对象在缓存服务器，则缓存服务器返回该对象
  - 若请求对象不在缓存服务器，则缓存服务器请求该对象并缓存，返回给客户机



#### Email应用组成

1. 邮件客户端(用户代理) user-agent
2. 邮件服务器
3. 邮件传输协议SMTP
   - 使用端口号25的TCP协议
   - 是一种‘推’协议，把内容推到对方邮件服务器，使用持久性连接
   - SMTP消息格式：
     - Header：To、From、Subject
     - Boby：消息本身，只能是ASCII字符
   - 邮件访问协议 (从服务器获取邮件)
     - POP协议(Post Office Protocol，无状态协议)：认证/授权(客户端-服务器)和下载
     - IMAP协议(Internet Mail Access Protocol):功能更多 能够操作服务器上的储存的消息
     - HTTP：163，qq mail





#### DNS

Domain Name System  基于UDP

1. 完成IP地址-域名的映射
2. 主机别名
3. 邮件服务器别名
4. 负载均衡：web服务器

域名服务器：

1. 根域名服务器 (本地域名服务器无法解析时访问根域名服务器)
2. 顶级域名服务器TLD 负责com,org,net,edu等顶级域名
3. 权威域名服务器(提供组织内部服务器的解析服务)
4. 本地域名解析服务器
   - 不严格属于层级体系
   - 每个ISP都有一个本地域名服务器，也是默认域名服务器
   - 主机查询DNS时，是向本地域名服务器发出请求

本地域名服务器查询方式：

- 迭代式：
  1. 被查询服务器返回域名解析服务器名字
  2. 我不知道这个域名，但是你可以问这个服务器
- 递归式：
  1. 将域名解析任务交给所联系的服务器

DNS记录缓存和更新：

1. 只要域名解析服务器获得域名-IP映射，那么就缓存这个映射
2. 一段时间后，该映射自动删除
3. 本地域名服务器一般缓存顶级域名服务器映射，因为根域名服务器不常被访问

DNS记录RR(Resource records)   RR format:(name,value,type,ttl)

1. Type =A     那么name是主机域名  value是IP地址
2. Type = NS 那么name是域  value是该域权威域名服务器主机域名
3. Type = CNAME 那么name是主机别名  value是真实域名
4. Type = MX 那么value是name对应的邮件服务器



#### P2P搜索信息

1. 集中式索引：信息到节点位置(IP地址+端口号)的映射

   问题：单点失效问题，性能瓶颈，版权问题

   内容和文件传输是分布式的，但是内容定位是集中式的

2. 洪泛查询Query flooding：

   完全分布式架构 每个节点对且只对他共享的文件进行索引

3. 层次式覆盖网络：

   介于集中式索引和洪泛查询之间

   每个节点是一个超级节点或被分配一个超级节点





## 传输层

#### 概述

传输层协议为运行在不同host上的进程提供了一种逻辑通信机制

- 发送方将应用层传下的消息分为一个/多个segment 交给网络层
- 接收方将收到的segment组成消息 交给应用层



#### 多路复用/分用

接收端多路分用：

- 传输层一局头部信息将收到的segment交给正确的socket 即不同的进程

发送端多路分用：

- 从多个socket接收数据 为每个数据封装头部信息，生成segment交给网络层

TCP的socket四元组标识：源IP地址，源端口号，目的IP地址，目的端口号



#### UDP

提供Best effort的尽力而为的服务，不保证可靠性

UDP是无连接的：

- UDP发送方和接收方之间无需握手建立连接
- 每个UDP的段的处理独立于其他段

UDP校验和：

- 发送方计算所有内容的和，进位加在和的后面，得到的值按位翻转，得到校验和
- 接收方计算收到的段的校验和   与校验和字段进行对比
  - 相等    没有检测出错误(有可能出错)
  - 不相等   检测出现错误

UDP报文段格式：

![image-20210621185911871](/Users/lizerun/Library/Application Support/typora-user-images/image-20210621185911871.png)

#### Rdt



###### Rdt1.0

基于可靠信道上的可靠数据传输(假设底层信道完全可靠(不会出错和丢失))

###### Rdt2.0

引入新机制：

- 引入校验和检测位错误

- 引入确认机制ACK：显示告诉发送方分组已经正确接受

- NAK：接收方显示告诉发送方分组有错误    发送方收到NAK后，重传分组

基于这种重传协议的Rdt成为ARQ协议(Automatic Repeat reQuest)



###### Rdt2.1

引入了序列号，解决Rdt2.0的ACK/NAK被破坏情况

###### Rdt2.2

扔掉了NAK 只需要ACK即可

- 接收方通过ACK告知最后一个被正确接收的分组
- 在ACK消息中显示加入被确认分组的序列号
- 发送方收到重复ACK，重传当前分组

###### Rdt3.0

引入定时器，如果在一定时间内没收到ACK，那么重传(若是因为延迟造成的，那么序列号机制也能够处理)



#### 流水线机制

允许发送方在收到ACK之前连续发送多个分组

发送方/接收方需要更大空间来缓存分组



#### 滑动窗口协议

窗口：允许使用的序列号范围

窗口尺寸为N：最多有N个等待确认的消息

滑动窗口协议：GBN  GO-BACk-N，SR  Selective-repeat

序列号空间大小与窗口尺寸关系：
$$
Ns + Nr ≤ 2^k
$$
Ns为发送窗口大小   Nr为接受窗口大小   k为序列号空间大小



###### Go-Back-N协议

是一种累计确认方式

Ack(n)：确认到序列号n的分组均已经正确接收

可能收到重复Ack

发送方：

- 设置定时器：若发生超时，重传序列号大于n且没收到Ack的分组

接收方：

- 乱序到达的分组直接丢弃，只确认序号高的按序到达的分组



###### Selective-Repeat协议

Ack不是累计确认，收到分组就返回该分组的Ack

- 设置缓存机制，缓存乱序到达的分组 而非像GBN那样直接丢弃
- 发送方只重传没收到Ack的分组





#### TCP

###### TCP概述

- TCP是全双工的，同一连接中可以双向传输数据流
- TCP是面向连接的
  - 通信前双方必须建立连接
  - 连接状态只在双方端点维护  沿途节点不维护

###### TCP段结构

![image-20210621201249402](/Users/lizerun/Library/Application Support/typora-user-images/image-20210621201249402.png)



###### TCP序列号和ACKs

TCP序列号：指的是报文段的第一个字节编号

建立连接时，双方随机选择序列号



TCP-ACKs

- 累计确认，该序列号之前的字节都已被收到
- 希望收到的下一个字节的序列号



###### TCP可靠数据传输

- 流水线机制
- 累计确认
- 单一重传计时器

触发重传事件：

1. 超时
2. 收到重复ACK



快速重传：

- 若收到统一数据的3个ACK(该数据以后的都丢失了)，那么在计时器超时之前进行重传



###### TCP流量控制

- 发送方不要发太快以至于淹没对方

接收方为TCP连接分配buffer

RcvWindow(未处理数据) + TCP data in buffer(应用层使用) = RcvBuffer

接收方通过segment的头部字段将RcvWindow大小告诉发送方

发送方限制自己已发送但未收到ack的数据不超过RcvWindow



###### TCP三次握手

1. 客户端发起请求，序列号seq = x，SYN=1 不能携带数据 大小为1
2. 服务器序列号seq = y，Ack = x+1，SYN=1 不能携带数据 大小为1
3. 客户端发送seq = x+1，Ack = y+1 ，SYN=0，可以携带数据



###### TCP四次挥手

1. client发送FIN=1的segment，进入FIN_WAIT_1状态
2. server收到，发送ACK，关闭连接，进入CLOSE_WAIT状态.发送FIN，client收到进入FIN_WAIT_2状态，server进入LAST_ACK状态
3. client收到，发送ACK，进入TIME_WAIT状态，若收到FIN，重新发送ACK
4. server收到ACK，连接关闭，



###### TCP拥塞控制

感知网络拥塞loss：

- timeout
- 三个重复ACK

发生loss事件后，发送方降低发送速率

加性增-乘性减：AIMD

- 每个RTT将CongWin增大一个MSS
- 发生loss将CongWin减半

慢启动：SS

- 每个RTT将CongWin翻倍
- 当目前Congwin到达loss的1/2时，加性增
- loss事件发生后，把Threhold置为CongWin的1/2

loss事件处理：

- 三个重复ACK：CongWin减小一半，然后线性增长
- timeout：CongWin设为一个MSS，指数增长到Threhold再线性增长







## 网络层



























